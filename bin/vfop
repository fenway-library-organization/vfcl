#!/usr/bin/perl

use strict;
use warnings;

use JSON;
use MARC::Loop;
use LWP::UserAgent;
use Fcntl qw(:seek);
use Getopt::Long
    qw(:config posix_default gnu_compat require_order bundling no_ignore_case);

sub usage;
sub fatal;

usage if !@ARGV;
my $cmd = shift @ARGV;

my $root = '/usr/local/vufind';
chdir $root or fatal "chdir $root: $!";

my $ua = LWP::UserAgent->new;
my $json = JSON->new;

&{ __PACKAGE__->can('cmd_'.$cmd) || usage };

# --- Command handlers

sub cmd_new {
    #@ new [-s SOLR] INSTANCE
    my $solr = 'default';
    orient(
        's|solr=s' => \$solr,
    );
    usage if @ARGV != 1;
    my ($instance) = @ARGV;
    create_instance(
        'name' => $instance,
        'solr' => $solr,
    );
}

sub cmd_status {
    #@ status [INSTANCE...]
    orient();
    @ARGV = all_instances() if !@ARGV;
    foreach (@ARGV) {
        my $instance = instance($_);
        show_status($instance);
    }
}

sub cmd_export {
    #@ export [-a] [-k BATCHSIZE] INSTANCE [RECORD...]
    my %form = qw(fl fullrecord start 0 rows 10);
    my $all;
    orient(
        'a|all' => \$all,
        'k|batch-size=i' => \$form{'rows'},
    );
    usage if !@ARGV;
    $instance = instance(shift @ARGV);
    my $total = 0;
    my @queries;
    if ($all) {
        usage if @ARGV;
        $form{'q'} = 'id:*';
        push @queries, { %form };
    }
    else {
        if (!@ARGV) {
            @ARGV = <STDIN>;
            chomp @ARGV;
        }
        while (@ARGV) {
            my @ids = splice @ARGV, 0, $form{'rows'};
            my $ids = join(' || ', map { 'id:' . $_ } @ids);
            $form{'q'} = $ids;
            push @queries, { %form };
            $form{'start'} += @ids;
        }
    }
    my $solr = solr($instance->{'solr'});
    my $host = $solr->{'host'} || 'localhost';
    my $port = $solr->{'port'} || 8080;
    foreach my $query (@queries) {
        my $remaining;
        my $uri = URI->new('http://${host}:${port}/solr/biblio/select');
        while (!defined($remaining) || $remaining > 0) {
            $uri->query_form(%$query);
            my $req = HTTP::Request->new('GET' => $uri);
            $req->header('Accept' => 'application/json');
            my $res = $ua->request($req);
            fatal $res->status_line if !$res->is_success;
            my $content = $json->decode($res->content);
            if (!defined $remaining) {
                $remaining = $content->{'response'}{'numFound'};
            }
            my @records = @{ $content->{'response'}{'docs'} };
            my $n = @records;
            last if $n == 0;
            print $_->{'fullrecord'} for @records;
            $remaining -= $n;
            $query->{'start'} += $n;
            $total += $n;
        }
    }
}

sub cmd_wipeout {
    print STDERR <<'EOS';
To delete all documents, run these commands:

url='http://localhost:8080/solr/biblio/update?commit=true'
data='<delete><query>*:*</query></delete>'
curl "$url" -H 'Content-Type: text/xml' --data-binary "$data"

EOS
    exit 2;
}

sub cmd_upgrade {
    update_ini_file('config/vufind/config.ini', 'System', sub {
        s/^(\s*autoConfigure\s*)=(\s*)false/$1=$2true/;
    });
}

# --- Other functions

sub oread {
    my ($file) = @_;
    open my $fh, '<', $file or fatal "open $file for reading: $!";
    return $fh;
}

sub oreadwrite {
    my ($file) = @_;
    open my $fh, '+<', $file or fatal "open $file for reading and writing: $!";
    return $fh;
}

sub update_ini_file {
    my $file = shift;

    my $fhin = oread($file);
    my @lines = <$fhin>;
    my $n = 0;
    for (@lines) {
        $n++ if $sub->();
    }
    if ($n) {
        my $tmpfile = '.~' . $file . '~';
        my $fhout = owrite($tmpfile);
        for (@lines) {
            print $fhout $_ if defined $_;
        }
        close $fhout or fatal "close $tmpfile: $!";
        my $bakfile = $file . '.bak';
        if (-e $bakfile) {
            unlink $bakfile or fatal "unlink $bakfile"
        }
        if (rename $file, $bakfile) {
            return $n if rename $tmpfile, $file;
            rename $bakfile, $file
                or fatal "rewrite $file: can't restore from $bakfile: $!";
        }
        else {
            fatal "rewrite $file: can't rename $file to $bakfile: $!";
        }

    }
    return 0;
}

sub orient {
    GetOptions(
        'i|instance=s' => \$instance,
        @_,
    ) or usage;

}

sub usage {
    print STDERR "usage: vfop COMMAND [ARG...]\n";
    exit 1;
}

sub fatal {
    print STDERR "vfop: @_\n";
    exit 2;
}
